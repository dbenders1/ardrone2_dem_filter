function dxdt = nonlinSim(t,sampleTimes,state,input,omegaR,param)
%QRODEFUN ODE implementation of quadrotor model.
%   This function provides the ODEs of the quadrotor model.
%   The ODEs used in this function contain the most (nonlinear) terms as
%   defined in the quadrotor model.

% State definition:
x       = state(1);     %x position in inertial frame
y       = state(2);     %y position in inertial frame
z       = state(3);     %z position in inertial frame
u       = state(4);     %linear velocity along x-axis in body frame
v       = state(5);     %linear velocity along y-axis in body frame
w       = state(6);     %linear velocity along z-axis in body frame
phi     = state(7);     %roll Euler angle
theta   = state(8);     %pitch Euler angle
psi     = state(9);     %yaw Euler angle
p       = state(10);    %angular velocity around x-axis in body frame
q       = state(11);    %angular velocity around y-axis in body frame
r       = state(12);    %angular velocity around z-axis in body frame

% Time-varying thrust and torque values
T           = interp1(sampleTimes,input(1,:),t);
tauPhi      = interp1(sampleTimes,input(2,:),t);
tauTheta    = interp1(sampleTimes,input(3,:),t);
tauPsi      = interp1(sampleTimes,input(4,:),t);
omegaInt    = interp1(sampleTimes',...
                      [omegaR(1,:)',omegaR(2,:)',omegaR(3,:)',omegaR(4,:)'],...
                      t);
omega       = -omegaInt(1) + omegaInt(2) - omegaInt(3) + omegaInt(4);

% Linear and angular rotation matrices (constructed using ZYX Euler
% angles):
R           = [cos(theta)*cos(psi), ...
               sin(phi)*sin(theta)*cos(psi) - cos(phi)*sin(psi), ...
               cos(phi)*sin(theta)*cos(psi) + sin(phi)*sin(psi);...
               cos(theta)*sin(psi), ...
               sin(phi)*sin(theta)*sin(psi) + cos(phi)*cos(psi), ...
               cos(phi)*sin(theta)*sin(psi) - sin(phi)*cos(psi);...
               -sin(theta), sin(phi)*cos(theta), cos(phi)*cos(theta)];

Rr          = [1, sin(phi)*tan(theta), cos(phi)*tan(theta);...
               0, cos(phi)           , -sin(phi);...
               0, sin(phi)/cos(theta), cos(phi)/cos(theta)];

% Ground constraint - part 1
if z < 0
    z = 0;
end

dxdt = [R(1,1)*u + R(1,2)*v + R(1,3)*w;...
        R(2,1)*u + R(2,2)*v + R(2,3)*w;...
        R(3,1)*u + R(3,2)*v + R(3,3)*w;...
        r*v - q*w + param.g*sin(theta);...
        p*w - r*u - param.g*cos(theta)*sin(phi);...
        q*u - p*v - param.g*cos(theta)*cos(phi) + 1/param.m*T;...
        Rr(1,1)*p + Rr(1,2)*q + Rr(1,3)*r;...
        Rr(2,1)*p + Rr(2,2)*q + Rr(2,3)*r;...
        Rr(3,1)*p + Rr(3,2)*q + Rr(3,3)*r;...
        1/param.ixx*((param.iyy - param.izz)*q*r - ...
        param.irotor*q*omega + tauPhi);...
        1/param.iyy*((param.izz - param.ixx)*p*r + ...
        param.irotor*p*omega + tauTheta);...
        1/param.izz*((param.ixx - param.iyy)*p*q + tauPsi)];

% Ground constraint - part 2
if abs(z) < param.groundThres && dxdt(6) < 0
    dxdt(6) = 0;
end
end